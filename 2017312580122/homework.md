# HomeWork5

**nslookup www.whu.edu.com**

![GCFFhD.png](https://s1.ax1x.com/2020/03/27/GCFFhD.png)

**P3**

> UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110, 01110100。这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出来吗？ 2比特的差错呢？

$01010011 + 01100110 + 01110100 = 100,101,101$
8比特回卷: $100,101,101 -> 00101110$
8比特反码: $00101110 -> 11010001$
原码和补码的计算, 随着系统的对字节保存方式的变化(大端/小端), 为了确保计算结果的正确性, 必须调用其他程序来验证, 造成额外的开销, 而反码对位置的置换并不敏感, 只需专注于原算法即可，且校验和算法简单快速，故采用反码检验和。
接收方将数据报所有16比特值之和与checkSum相加，若结果为$(1 << 16) - 1$, 那么接收方认为数据无差错。
1比特的差错必定会使得上述结果的比特序列中出现一个0，所以肯定能检测出来。
而2比特的差错，假如这两个比特的差错产生和互补的效果，则检测不出来。比如，第一个子序列的最后一个数字变成0，而第二个子序列的最后一个数字变成1，那么不影响它们之和，则结果不便，接收端认为无差错。

**P7**

> 在rdt3.0协议中，从接收方向发送方流动的ACK分组没有序号（尽管它们具有ACK字段，该字段包括了它们正在确认的分组的序号）。为什么这些ACK分组不需要序号呢？

序列号让接收方判断是否接收过该数据包的内容。在ACK的情况下，接收方不需要这个信息(即ACK上的序列号)来判断是否检测到重复的ACK。对于rdt3.0接收器来说，一个重复的ACK是显而易见的，因为当它接收到原始ACK时，它会转换到下一个状态。重复的ACK不是发送方需要的ACK，因此被rdt3.0发送方忽略。
